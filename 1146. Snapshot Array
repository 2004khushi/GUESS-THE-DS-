class SnapshotArray {
public:
    int snap_id;
    unordered_map<int, vector<pair<int,int>>> mp;//[index -> (snap_id, value)]


    SnapshotArray(int length) {
        snap_id = 0;

        // length = mp.size();
        // for(int i=0; i<length; i++){
        //     mp[i]={0,0};
        // }

        //no need to do these bcs map already knows it will. be zero only it's not a vector
    }
    
    void set(int index, int val) {
        // we can optimise this -> mp[index].push_back({snap_id, val});
        //let's just keep the last updated value only in our vector ->

        if(!mp[index].empty() && mp[index].back().first == snap_id){
            mp[index].back().second = val;
        }else{
            mp[index].push_back({snap_id, val});
        }

    }
    
    int snap() {

        return snap_id++;

        //OR

        // snap_id ++;
        // return snap_id-1;
    }
    
    int get(int index, int snap_id) {

        if(mp.find(index) == mp.end()) return 0;

        auto it = upper_bound(begin(mp[index]), end(mp[index]), make_pair(snap_id, INT_MAX) );
        //int_max bcs eg-> get(1, 0) so when upperbound will compare it'll compare 0 with 0 and see next iNT_MAX with any will make us(upper_bound) only big so eventually jiski snap_id 1 hogi first time me vhi pointer dega vo as answer. Now how upper_bound is actuualy helping is see, let's say we have only this in mp -> mp[0] = [ {0, 30}, {2, 50} ]
        //so if get(0,1) -> kuch h hi nhi agar tum normal search lagaate to vo 0 ya null return krta but WE R TAKING SNAPS yaani jo last store tha us jagah vo dikhana hi hoga so bcs 1 is smaller then 2 2 pe pointer aayega and with prev(it)->second we'll get access of (0,30) hence answer would be 30. or if had 2 be not there then pointer would had point at .end() so again prev(it)->second we'll get access of (0,30).

        //Hence UPPER_BOUND was imp here!

        if (it == begin(mp[index])) {
            return 0;
        }

//         If you ask for get(index, 0) but the first time you ever set that index was at snap_id = 5, the upper_bound will return mp[index].begin().
// When you then call prev(it), you are moving the iterator before the start of the vector.

        return prev(it)->second;
    }
};

