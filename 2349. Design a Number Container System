Approach1 -> Sabse pehle array socha ofc , but 10^9 tak jaa skta h so waste h array!

Approach2 ->
map to already socha hi tha ki bhai [number,vec<int> for all it's indices in sorted form] so vec nhi lenge set lenge! bcs sort me rkhna h , taaki set.begin() pointer use krke answer dede fast! and .erase(number) se easily del krde use as well all in O(1). ab index with number bhi ek map me save krlete hai! u must be wondering ye kyu chhaiye right? , dekho it might happen ki eg -> map first wala jo tha usme ->
	[10 -> <1,3,4,5,8,23,67,45,.....> and so on and 45 pe ab mene daaldiya hai 20 ko ; to tum dhundte thodi bethoge ki bhai kya 45 10 me h ya koi or number pe h ! to make this easier we will make one more map! SMJHE???
where .insert and .erase worst me 0(logn) jaayenge


class NumberContainers {
public:

    unordered_map<int,int> mp1;
    unordered_map<int, set<int>> mp2;
    NumberContainers() {}

    void change(int index, int number) 
    {
        if(mp1.count(index)){
            int prevnum = mp1[index];
            mp2[prevnum].erase(index);
            if(mp2[prevnum].empty()){
                mp2.erase(prevnum);
            }
        }
        mp1[index] = number;
        mp2[number].insert(index);
    }
    int find(int number) 
    {
        return mp2.count(number)? *mp2[number].begin() : -1;
    }

};